var Helper = require('./skynet_helper');
Log = Helper().logger;

function *rangeGenerator(start, end, step){
  let i = start, e = end, st = step;
  for(; i < e; i += st){
    yield i;
  }
}

const range = (start, end, step)=>{
  let _range = [];
  const s = start, e = end, st = step|1; 
  for(let v of rangeGenerator(s, e, st)){
    _range.push(v);
  }
  return _range;
}
// Log('[statTest] range')
// s = new Date();
// Log(range(0,1000,1).length === 1000);
// r = new Date() - s;
// Log('[endTest] runtime '+r+' ms');

//*Immutable function*
const reverse = (arr)=>arr.slice().reverse();
const set  = (arr,i, key,value)=> {
  let arrNew = arr.slice();
  const idx  = remapIndex(i, arrNew.length);
  if(key){ arrNewkey[idx].key = value; }
  else{ arrNewkey[idx] = value; }
  return arrNew;
}
const get  = (arr,i, key)=> key?arr.slice(i,i+1)[0][key]:arr.slice(i,i+1)[0];
const splice   = (arr,i,j)=>j?arr.slice().splice(i,j):arr.slice().splice(i);
const getFirst = (arr, key)=> key?arr.slice(0,1)[0][key]:arr.slice(0,1)[0];
const getLast  = (arr, key)=> key?arr.slice(-1)[0][key]:arr.slice(-1)[0];
const clone = (refValue)=>{
  return (refValue instanceof Array)?
  Object.assign([],refValue):Object.assign({},refValue);
}

const validateShape = (shapeA, shapeB)=>{
  if(''+shapeA !== ''+shapeB){ throw Error('shape not consistent') }
}

const getVolume = (shape)=>shape.reduce((a,b)=>a*b)
const ShAndVol  = (shape)=>{
  vol = reverse(shape).reduce((cs,d,i,sh)=>
    cs.concat(i>0?getLast(cs)*sh[i-1]:1),
    []).reverse();
  return shape.map((d,i)=>{ return {sp:d,vol:vol[i]} })
}
// Log('[statTest] ShAndVol')
// s = new Date();
// Log(ShAndVol([2,2,3])); //
// r = new Date() - s;
// Log('[endTest] runtime '+r+' ms')

const remapIndex = (idx,sh)=>{
  idx = (idx>-1)?idx:sh + idx
  if(idx <0 || idx >= sh){ throw Error('index invalid'); }
  else{ return idx; }
}

const remapSelect = (sval, shape)=>{
    //numpy like selector
    vsp = sval.split(',');
    if(vsp.length > shape.length){
      throw Error('selector is not consitent with shape')
    }
    select = shape.map((sh,i)=>{
      let v = (i<vsp.length)?vsp[i]:':';
      console.log(v,sh);
      if(!+v) { 
        let [l,h,st] = v.split(':');
        st = st? +st:1;
        l  = l ? +l:(st>0)?0:sh-1, 
        h  = h ? +h:(st>0)?sh:0;
        let check=[];
        check.push((h>sh)?
          `IndexError: ${h} higher than ${sh}`:null);
        check.push((st<0&&h>l)?
          `IndexError: if st < 0, ${l} higher than ${h}`:null);
        if(check.filter(d=>d).length){
          throw Error(''+check);
        }
        return [l,h,st];
      }
      else { return remapIndex(+v,sh) } 
    });
    return select;
}

console.time('remap');
// Log(remapIndex(0,4)); //0
// Log(remapIndex(-5,4)); //error
console.timeEnd('remap');

console.time('remapselect')
remapSelect('1:2:2,:,::-1,0:2:12,1',[4,3,3,4,5]);
console.time('remapselect')

function *indexGenerator(selector, space, axis, idx){
  axis = axis | 0;
  idx = (idx)?idx:selector.map(()=>0);
  const l = selector[axis][0]|selector[axis], 
        h = selector[axis][1]|l+1,
        s = selector[axis][2]|1;
  idx[axis] = l;
  //TODO: check if we
  while(s>0?(idx[axis] < h):false){
    if(axis+1<selector.length){
      yield *indexGenerator(selector,space,axis+1,idx);
      idx[axis] += s;
    }
    else{
      yield {idx:idx,vx:idx.reduce((s,d,i)=>s+d*space[i],0)};
      idx[axis] += s;
    }
  }
}

console.time('generatorF1');
for(let idx of indexGenerator([[0,20,1],29],[30,1])){
  console.log(idx.vx, ''+idx.idx);
}
console.timeEnd('generatorF1');

const ravel = (a) => a.reduce((s,a)=>{return (a instanceof Array)?s.concat(ravel(a)):s.concat(a)},[]);

const getAtFunc = (value)=>{
  if(typeof value === 'number'){
    return {getAt:(value,counter)=>value};
  }
  if(a instanceof Array){
    let valueFlatten = ravel(value);
    return {getAt:(value,counter)=>value[counter]};
  }
  if(a instanceof numberjs){
    let v = value.value;
    return {getAt:(value,counter)=>v[counter]};
  }
}

Selector = {
  get:function(d, selectString){
    value = d.v, shape = d.s; 
    selector = remapSelect(selectString, shape);
    shapeNew = selector.map((d,i)=>(d===true)?shape[i]:d.length).filter(d=>d>1);
    valueNew = new Float32Array(getVolume(shapeNew));
    //TODO: consider to rewrite this part
    let c = 0;
    for(let px of indexGenerator(selector)){
      idx = px.idx, vx = px.vx;
      valueNew[c] = value[vx]; 
      c ++;
    }
    return new numberjs(valueNew, shapeNew);
  },
  set:function(d, selectString, newValue){
    value = d.v, shape = d.s; 
    selector = remapSelect(selectString, shape);
    const getAtFunc = (value)=>{
      if(typeof value === 'number'){
        return {getAt:(counter)=>value};
      }
      if(value instanceof Array){
            //TODO: implement check shape
            let valueFlatten = ravel(value);
            return {getAt:(counter)=>value[counter]};
          }
          if(value instanceof numberjs){
            //TODO: implement check shape
            let v = value.value;
            return {getAt:(counter)=>v[counter]};
          }
        }
        func = getAtFunc(newValue);
        for(let px of indexGenerator(shape, selector, true)){
          idx = px.idx, c = px.c;
          vx  = reverse(idx).reduce((v,d,i)=>v+d*shape[i]);
        // Log([vx, newValue]);
        value[vx] = func.getAt(c);
      }
      return d;
    }
  }

  const getShape = (arr)=>(typeof arr === 'number')?
  null:[arr.length].concat(getShape(arr[0])).filter(d=>d)
// Log('[statTest] getShape')
// s = new Date();
// Log(getShape([2,2])); //2
// Log(getShape([[2,2],[1,1]])); //[2,2]
// r = new Date() - s;
// Log('[endTest] runtime '+r+' ms')

// function numberjs(value, shape){
//   if(shape){
//     this.shape  = clone(shape);
//     this.volume = getVolume(this.shape);
//     this.space  = getSpace(this.shape);
//     this.value  = value;
//   }
//   else if(value){
//     _shape  = getShape(value);
//     this.shape = clone(_shape);
//     this.volume = getVolume(this.shape);
//     this.space  = getSpace(this.shape);
//     this.value  = new Float32Array(this.volume);
//     for(let px of indexGenerator(this.shape,false,true)){
//       let idx = px.idx, c = px.c;
//       this.value[c] = idx.reduce((v,i)=>v[i],value);
//     }
//   }
//   else{
//         //TODO: this is op instance
//         this.grad = null;
//       }
//       this.version = 0.1;
//       this.v = new Proxy({v:this.value, s:this.shape}, Selector);
// }


    numberjs.prototype.tolist = function(){
      let list = reverse(this.shape).reduce((l,s)=>{
        ll = l.reduce(
          (d,v)=>{
            d.tmp.push(v);
            if(d.tmp.length===s){
              d.t.push(d.tmp);
              d.tmp = [];
            }
            return d;
          },{t:[],tmp:[]});
        return ll.t;
      }, this.value)[0];
      return list;
    }

    numberjs.prototype.T = function(){
      let shapeNew = reverse(this.shape);
      let valueNew = new Float32Array(getVolume(shapeNew));
      for(let px of indexGenerator(shapeNew, false)){
        idx = px.idx, c = px.c, vx=px.vx;
        rix = reverse(idx);
        vdx = reverse(rix).reduce((v,d,i)=>v+d*this.shape[i]);
        valueNew[c] = this.value[vdx]; 
      }
      return new numberjs(valueNew, shapeNew);
    };

    numberjs.prototype.reshape = function(newShape){
      validateShape(this.shape, newShape);    
      this.shape = clone(newShape);
      return this;
    };

    numberjs.prototype.tanh = (a)=>{
      let val = a.value.map(d=>Math.tanh(d));
      return new numberjs(val, a.shape);
    }

    numberjs.prototype.relu = (a)=>{
      throw 'not implement';
    };

    numberjs.prototype.sigmoid = (a)=>{
      val = a.value.map(d=>0.5*(Math.tanh(d)+1.0));
      return new numberjs(val, a.shape);
    }

    const vecMapping = (vA, vB, ops)=>{
      validateShape(vA.shape, vB.shape);
      return vA.map((d,i)=>ops(vA[i],yB[i]));
    }

    const numMapping = (vA, n, ops)=>{
      return vA.map((d,i)=>ops(vA,n));
    }

    const validateOps = (objA, objB)=>{
      if(   typeof objA === 'numberjs' 
       && typeof objB === 'numberjs' ){
        return vecMapping;
    }
    if(   typeof objA === 'numberjs' 
     && typeof objB === 'number' ){
      return numMapping;
  }
  throw Error('invalide objet input');
}

numberjs.prototype.add = (a,b)=>{
  const addOp   = (d1,d2)=>d1+d2;
  const mapping = validateOps(a,b);
  let value = mapping(a, b, addOp);
  return new numberjs(value, a.shape);
};

numberjs.prototype.minus = (a,b)=>{
  const minusOp = (d1,d2)=>d1-d2;
  const mapping = validateOps(a,b);
  let value = mapping(a, b, minusOp);
  return new numberjs(value, a.shape);
};

numberjs.prototype.mul = (a,b)=>{
  const mulOp   = (d1,d2)=>d1*d2;
  const mapping = validateOps(a,b);
  let value = mapping(a, b, mulOp);        
  return new numberjs(value, a.shape);  
};

numberjs.prototype.div = (a,b)=>{
  const divOp   = (d1,d2)=>d1/d2;
  const mapping = validateOps(a,b);
  let value = mapping(a, b, divOp);     
  return new numberjs(value, a.shape);
};

const validateDotOps = (objA, objB)=>{
  if(   typeof objA === 'numberjs' 
   && typeof objB === 'numberjs' ){
    return DotvecMapping;
}
if(   typeof objA === 'numberjs' 
 && typeof objB === 'number' ){
  return DotnumMapping;
}
if(   typeof objA === 'numberjs' 
 && typeof objB === 'number' ){
  return DotnumMapping;
}
throw Error('invalide objet input');
}

numberjs.prototype.dot = function(a,b){
    // validateDotShape(a.shape,b.shape);
    const aShape = a.shape, bShape = b.shape;
    let newShape = splice(aShape,0,aShape.length-1).concat(splice(bShape,-1));
    let newValue = new Float32Array(getVolume(newShape));
    // Log(['newShape', newShape]);
    // Log(a.value);
    // Log(b.value);
    
    for(let px of indexGenerator(newShape, false, true)){
      const idx = px.idx, c = px.c;
      aSelector = idx.map((d,i,ii)=>(i != ii.length-1)?[d]:true);
      bSelector = idx.map((d,i,ii)=>(i != ii.length-2)?[d]:true);
        // Log(['idx', ''+idx]);
        // Log(['aSelector', ''+aSelector]);
        // Log(['bSelector', ''+bSelector]);
        let aV = [],bV = [];
        // console.time('px');
        for(let apx of indexGenerator(aShape, aSelector, true)){
            // Log(['aLog', ''+apx.idx, apx.c, a.value[apx.vx]]);
            aV.push(a.value[apx.vx]);
          };
          for(let bpx of indexGenerator(bShape, bSelector, true)){
            // Log(['bLog', ''+bpx.idx, bpx.c, b.value[bpx.vx]]);
            bV.push(b.value[bpx.vx]);
          };
          newValue[c] = aV.reduce((tt,a,i)=>tt+aV[i]*bV[i],0);
        // console.timeEnd('px');
      }

      return new numberjs(newValue, newShape);
};

numberjs.prototype.dotF = function(a,b){
    // validateDotShape(a.shape,b.shape);
    const aShape = a.shape, bShape = b.shape;
    let newShape = splice(aShape,0,aShape.length-1).concat(splice(bShape,-1));
    let newValue = new Float32Array(getVolume(newShape));
    // Log(['newShape', newShape]);
    // Log(a.value);
    // Log(b.value);
    
    for(let px of indexGenerator(newShape, false, true)){
      const idx = px.idx, c = px.c;
      aSelector = idx.map((d,i,ii)=>(i != ii.length-1)?[d]:true);
      bSelector = idx.map((d,i,ii)=>(i != ii.length-2)?[d]:true);
      let aV = [],bV = [];
      aGen = indexGenerator(aShape, aSelector, true);
      bGen = indexGenerator(bShape, bSelector, true);
      for(let apx = aGen.next(), bpx = bGen.next();
        !(apx.done&&apx.done);
        apx = aGen.next(), bpx = bGen.next() ){
        apx = apx.value;
      bpx = bpx.value;
            // Log(['aLog', ''+apx.idx, apx.c, a.value[apx.vx]]);
            // Log(['bLog', ''+bpx.idx, bpx.c, b.value[bpx.vx]]);
            newValue[c] += a.value[apx.vx]*b.value[bpx.vx];
          };
        }
        return new numberjs(newValue, newShape);
      };

      function Numberjs(value, shape){
        return new numberjs(value, shape);
      }
      module.exports = Numberjs;